<!-- Generated by SpecStory -->

# 初回チャット送信時のモデル設定について (2025-05-22 06:30Z)

_**User**_

初めてチャットを送ると、設定もモデル欄が大量になるのはなぜ？

---

_**Assistant**_

ユーザー様からのご質問ありがとうございます。最初のチャットを送信した際に、設定やモデルの欄が大量に表示される件についてですね。

この現象は、チャットロジック内でのモデルリストの管理方法に関連している可能性が高いです。具体的に考えられる原因と、その中でも特に可能性の高いものを以下に示します。

**考えられる原因**

1.  **モデルリストの初期化ロジックの不備**: アプリケーション起動時やチャットルーム入室時に、APIから取得した全モデルリストと、ローカルストレージ等に保存されているユーザーの選択モデル情報をマージする処理があります。このマージロジックが、初回送信の特定の条件下で意図せず全モデルを選択状態にしてしまっている可能性があります。 (`hooks/useChatLogic.ts` の L1015-L1118 付近の `useEffect` フック)
2.  **`handleSend` 関数内のモデル処理の問題**: メッセージ送信処理 (`handleSend`) の中で、実際にAPIリクエストに使用するモデルを決定しています。この部分で、何らかの理由により、ユーザーが意図しない多数のモデルが選択対象として扱われている可能性があります。 (`hooks/useChatLogic.ts` の L328-L513 付近)
3.  **ローカルストレージデータの不整合**: ローカルストレージに保存されているモデルの選択状態 (`models`) やチャット履歴 (`chatMessages_XXX`) が、予期せぬ形式や古い情報になっている場合、アプリケーションの読み込み時やメッセージ送信時に問題を引き起こし、結果として全モデルが選択されているように見えることがあります。
4.  **デフォルトモデル設定の副作用**: `DEFAULT_MODEL_IDS` で定義されたデフォルトモデルを選択するロジックが、他のモデルリスト処理と競合したり、意図しない形で他のモデルも選択状態にしてしまう可能性があります。
5.  **状態更新のタイミングと競合**: `messages` (メッセージリスト)、`models` (モデルリスト) といった複数の状態が、`useEffect` フックやコールバック関数によって非同期的に更新されます。これらの更新処理が予期せぬ順序で実行されたり、競合したりすることで、一時的に、あるいは永続的にモデルリストが不正な状態になる可能性があります。
6.  **`fetchOpenRouterModels` から返されるデータの想定外の構造**: APIからモデルリストを取得する `fetchOpenRouterModels` 関数の結果が、後続の処理で期待されている形式と異なっている場合、モデルの選択ロジックが正しく機能しない可能性があります。
7.  **初期読み込み完了フラグ (`initialLoadComplete`) の影響**: 各種データの初期読み込みが完了したことを示す `initialLoadComplete` フラグの管理に問題があり、モデルリストの初期化処理が不適切なタイミングで再実行されたり、あるいは初回送信のタイミングで誤った状態を参照している可能性があります。

**最も可能性の高い原因**

上記の原因の中でも、特に以下の1と5が複合的に関与している可能性が高いと考えられます。

*   **1. モデルリストの初期化ロジックの不備**: 特に、`AllModels` (APIから取得した全モデルリスト) とローカルストレージに保存されている `models` (ユーザー選択モデル) をマージし、最終的な表示モデルリストを生成するロジックに問題がある可能性があります。初回メッセージ送信がトリガーとなり、このロジックが再評価され、意図せず多くのモデルが選択状態になっているのかもしれません。
*   **5. 状態更新のタイミングと競合**: `handleSend` 関数が実行されると、メッセージリスト (`messages` や `optimisticMessages`) とモデルの状態 (`models`) に基づいて処理が進みます。この時、`models` の状態が最新でない、あるいは `handleSend` の処理中に `models` が予期せず更新されることで、多数のモデルが選択されているかのような挙動に繋がる可能性があります。

**仮説検証のためのログ追加提案**

この問題を正確に診断するために、まず以下の箇所にログ出力を追加し、モデルリストがどのように変化しているか、また `handleSend` 関数実行時のモデルの状態を確認することをご提案します。これにより、どの段階で意図しないモデル選択が発生しているのかを特定できます。

ファイル: `hooks/useChatLogic.ts`

1.  `handleSend` 関数の開始直後、選択されているモデルを確認するためにログを追加します。
    ```typescript
    // ...
    const handleSend = useCallback(
      async (userInput: string) => {
        console.log("[handleSend] Called with input:", userInput);
        // ▼▼▼ ログ追加 ▼▼▼
        console.log("[handleSend] Current models state at start of handleSend:", JSON.stringify(models?.map(m => ({ id: m.id, name: m.name, selected: m.selected }))));
        // ▲▲▲ ログ追加 ▲▲▲
        console.log(
          "[handleSend] Current models state:",
          JSON.parse(JSON.stringify(models))
        );
        setError(null);
    // ...
    ```
    そして、`currentSelectedModels` が定義された直後にもログを追加します。
    ```typescript
    // ...
        const currentSelectedModels = models?.filter((m) => m.selected) || [];
        // ▼▼▼ ログ追加 ▼▼▼
        console.log("[handleSend] Calculated currentSelectedModels:", JSON.stringify(currentSelectedModels.map(m => ({ id: m.id, name: m.name }))));
        // ▲▲▲ ログ追加 ▲▲▲
        console.log(
          "[handleSend] Current selected models:",
          JSON.parse(JSON.stringify(currentSelectedModels))
        );
    // ...
    ```

2.  モデルリストの初期化と同期を行っている `useEffect` フック (L1015 付近) の中で、`setModels` を呼び出す直前の `newModelList` の内容と、その中で選択されているモデルの数を確認します。
    ```typescript
    // ...
        // 設定を保存
        console.log(
          "[useEffect models] Setting models based on AllModels and storedModels, total count:",
          newModelList.length,
          "selected:",
          newModelList.filter((m) => m.selected).length
        );
        // ▼▼▼ ログ追加 ▼▼▼
        console.log("[useEffect models] newModelList just before setModels:", JSON.stringify(newModelList.map(m => ({ id: m.id, name: m.name, selected: m.selected }))));
        console.log("[useEffect models] Number of selected models in newModelList before setModels:", newModelList.filter(m => m.selected).length);
        // ▲▲▲ ログ追加 ▲▲▲
        setModels(newModelList);
      }, [AllModels]);
    // ...
    ```

これらのログ情報を開発者ツールなどで確認いただくことで、初回メッセージ送信時にモデルリストがどのように扱われているかの詳細な情報が得られます。その情報を元に、より具体的な原因特定と修正案の検討に進めさせていただければと思います。

お手数ですが、上記ログを追加してアプリケーションを動作させ、初回メッセージ送信後のコンソールの出力を共有いただけますでしょうか。

---

_**User**_

問題は解決したきが数ビューポート。

ただしプロンプトを送信した時の送信先が「google/gemini-2.0-flash-001とopenai/gpt-4o-mini」で固定になってない？設定モーダルで設定したものを採用してください。（値がない場合はサイトにアクセスした時点で自動的にローカルストレージを指定）

---

_**Assistant**_

プロンプト送信時の送信先モデルが固定されてしまう件、承知いたしました。
設定モーダルで選択したモデルが正しくAPIリクエストに利用され、ローカルストレージの値も適切に読み込まれるように、モデルリストの初期化ロジックを改善する必要がありますね。

現在の `handleSend` 関数は、`models` ステートの `selected: true` となっているモデルを使用する設計になっています。問題は、この `models` ステートが、ユーザーの選択を正しく反映していないか、あるいは古い状態を参照している可能性にあります。

特に、`useEffect` フック（`hooks/useChatLogic.ts`のL1015付近）によるモデルリストの初期化処理が、ローカルストレージからのモデル設定の読み込みタイミングや、APIからの全モデルリスト取得のタイミングとの間で競合し、ユーザーの選択が意図せずデフォルト設定で上書きされてしまうシナリオが考えられます。

この問題を解決するために、モデルリストの初期化と同期を行う `useEffect` フックを以下のように修正することをご提案します。この修正は、ローカルストレージからの設定読み込みが完了し、かつAPIからの全モデルリストが取得できた後に、一度だけ初期同期処理を実行し、その後はユーザーによる設定変更を妨げないようにすることを目的としています。

ファイル: `hooks/useChatLogic.ts` (L1015付近の`useEffect`を置き換えます)


---

```diff
    }, []); // fetchOpenRouterModelsを依存配列から削除、初回のみ実行
  
-   // モデルリストの初期化と同期ロジック (AllModelsが取得されてから実行)
+   // モデルリストの初期化と同期ロジック
    useEffect(() => {
-     if (AllModels.length === 0) {
+     // models が undefined (useStorageState がロード中) か、AllModels が空なら処理しない
+     if (models === undefined || AllModels.length === 0) {
        console.log(
-         "[useEffect models] Skipping initialization because AllModels is empty"
+         `[useEffect models sync] Skipping: models is ${models === undefined ? 'undefined' : 'defined (length: ' + (models?.length || 0) + ')'}, AllModels length is ${AllModels.length}`
        );
        return;
      }
  
-     // 既に初期化済みならスキップ
+     // 既に初期化が完了していれば、再度の初期化処理は行わない
+     // ユーザーが設定モーダルで選択を変更した場合、このuseEffectがその変更を上書きするべきではない
      if (modelsInitialized.current) {
-       console.log("[useEffect models] Already initialized, skipping");
+       console.log("[useEffect models sync] Already initialized, skipping initial sync.");
        return;
      }
-     modelsInitialized.current = true;
  
-     // ローカルストレージから読み込まれたモデル設定
+     // --- ここからが実際の初期化処理 ---
+     console.log("[useEffect models init] Performing initial model list synchronization.");
+ 
+     // 'models' はローカルストレージから読み込まれた（あるいはuseStorageStateの初期値の）ModelItem[]
      const currentStoredModels = models;
+     let newModelList: ModelItem[];
  
-     console.log("[useEffect models] Initializing models from AllModels");
-     console.log("[useEffect models] AllModels count:", AllModels.length);
-     console.log("[useEffect models] DEFAULT_MODEL_IDS:", DEFAULT_MODEL_IDS);
-     console.log(
-       "[useEffect models] First model:",
-       AllModels[0]?.id,
-       AllModels[0]?.name
-     );
- 
-     let newModelList: ModelItem[] = [];
- 
-     if (currentStoredModels && currentStoredModels.length > 0) {
-       console.log(
-         "[useEffect models] Using stored models with count:",
-         currentStoredModels.length
+     if (currentStoredModels.length > 0) {
+       console.log(
+         `[useEffect models init] Using stored models (count: ${currentStoredModels.length}) and merging with AllModels (count: ${AllModels.length})`
        );
- 
        // ローカルストレージのモデルリストで、IDがないが名前があるものにはIDを補完する
        const enhancedStoredModels = currentStoredModels.map((storedModel) => {
```

```diff
      } else {
        console.log(
-         "[useEffect models] No stored models, creating new list with default selected"
+         "[useEffect models init] No stored models, creating new list from AllModels with default selections."
        );
        // ローカルストレージに設定がなければ、AllModelsからデフォルトを設定
```

```diff
      }
  
-     // 選択されたモデルの確認
-     const selectedModels = newModelList.filter((m) => m.selected === true);
+     // 選択されたモデルの確認とフォールバック
+     let finalSelectedModels = newModelList.filter((m) => m.selected);
      console.log(
-       "[useEffect models] Selected models after initial mapping:",
-       selectedModels.length
+       `[useEffect models init] Selected models after initial mapping: ${finalSelectedModels.length}`
      );
  
-     // 選択モデルがない場合は設定
-     if (selectedModels.length === 0 && newModelList.length > 0) {
+     if (finalSelectedModels.length === 0 && newModelList.length > 0) {
        console.log(
-         "[useEffect models] No model selected, setting default models"
+         "[useEffect models init] No model selected, attempting to set default models."
        );
- 
-       // デフォルトモデルを探す
        for (const defaultId of DEFAULT_MODEL_IDS) {
          const defaultModel = newModelList.find((m) => m.id === defaultId);
          if (defaultModel) {
-           console.log(`[useEffect models] Found default model: ${defaultId}`);
            defaultModel.selected = true;
          }
        }
- 
-       // デフォルトモデルが見つからなかった場合は最初のモデルを選択
-       if (
-         newModelList.filter((m) => m.selected).length === 0 &&
-         newModelList[0]
-       ) {
+       finalSelectedModels = newModelList.filter((m) => m.selected); // 再度確認
+       if (finalSelectedModels.length === 0 && newModelList[0]) {
          console.log(
-           `[useEffect models] Default models not found, selecting first model: ${newModelList[0]?.id}`
+           `[useEffect models init] Default models not found/applicable, selecting first model: ${newModelList[0]?.id}`
          );
          newModelList[0].selected = true;
-       }
-     }
- 
-     // 最終確認
-     const finalSelectedModels = newModelList.filter((m) => m.selected === true);
-     console.log(
-       "[useEffect models] Final selected models count:",
-       finalSelectedModels.length
-     );
- 
-     if (finalSelectedModels.length > 0) {
-       console.log(
-         "[useEffect models] Selected model IDs:",
-         finalSelectedModels.map((m) => m.id)
-       );
-     } else if (newModelList.length > 0) {
-       console.warn(
-         "[useEffect models] WARNING: No models selected after initialization!"
-       );
-       // 最後の手段として先頭モデルを選択
-       newModelList[0].selected = true;
-       console.log(
-         `[useEffect models] Forced selection of first model: ${newModelList[0].id}`
-       );
-     } else {
-       console.error("[useEffect models] ERROR: No models available at all!");
-       // 最低1つのモデルは必要なので、デフォルトモデルを作成
-       newModelList = [
-         {
-           id: DEFAULT_MODEL_IDS[0],
-           name: "GPT-4o Mini",
-           selected: true,
-         },
-       ];
-       console.log("[useEffect models] Created default model as fallback");
+         finalSelectedModels = newModelList.filter((m) => m.selected); // 再度確認
+       }
+     }
+     
+     if (finalSelectedModels.length === 0 && newModelList.length === 0) {
+       console.warn("[useEffect models init] No models available in AllModels. Creating fallback default models.");
+       // AllModelsが空の場合でも、最低限デフォルトモデルを表示するためのフォールバック
+       newModelList = DEFAULT_MODEL_IDS.map(id => {
+         // 簡単な名前を生成（例: "openai/gpt-4o-mini" -> "gpt-4o-mini"）
+         const nameParts = id.split('/');
+         const simpleName = nameParts.length > 1 ? nameParts.slice(1).join('/') : id;
+         return {
+           id: id,
+           name: simpleName, 
+           selected: true // デフォルトなので選択状態にする
+         };
+       });
+        // 最初のデフォルトモデルのみを選択状態にする場合
+       if (newModelList.length > 1) {
+         newModelList = newModelList.map((model, index) => ({...model, selected: index === 0}));
+       }
+       finalSelectedModels = newModelList.filter((m) => m.selected);
      }
  
-     // 設定を保存
+ 
      console.log(
-       "[useEffect models] Setting models based on AllModels and storedModels, total count:",
-       newModelList.length,
-       "selected:",
-       newModelList.filter((m) => m.selected).length
+       `[useEffect models init] Setting models. Total: ${newModelList.length}, Selected: ${finalSelectedModels.length} (${finalSelectedModels.map(m=>m.id).join(', ')})`
      );
- 
+     
      setModels(newModelList);
-   }, [AllModels]); // modelsを依存配列から削除して無限ループを防ぐ
+     modelsInitialized.current = true; // 初期化完了をマーク
+     console.log("[useEffect models init] Initial model synchronization complete. modelsInitialized.current set to true.");
+ 
+   }, [AllModels, models, setModels]); // models, setModels を依存配列に追加
  
    // 初期メッセージ読み込みuseEffect
```

---

修正案を適用しました。

主な変更点は以下の通りです。

1.  **依存配列の変更**: `useEffect` フックの依存配列に `models` と `setModels` を追加しました。これにより、`useStorageState` から `models` の値が非同期にロードされた際に、この `useEffect` が正しく再実行され、ローカルストレージの値に基づいた初期化が行われることを意図しています。
2.  **初期化フラグの改善**: `modelsInitialized.current` フラグを、実際の初期化処理が完了した後に `true` に設定するようにしました。また、このフラグが `true` の場合は、後続のユーザーによる設定変更を上書きしないように、初期化処理をスキップするようにしました。
3.  **`models` のロード状態の考慮**: `useEffect` の冒頭で `models === undefined` (つまり `useStorageState` による読み込みが完了していない状態) の場合は処理をスキップするようにしました。これにより、未定義の `models` に対して処理を行おうとすることを防ぎます。
4.  **フォールバック処理の強化**: `AllModels` が空の場合でも、`DEFAULT_MODEL_IDS` に基づいてフォールバックのモデルリストを生成し、少なくとも1つはモデルが選択された状態になるようにしました。これにより、APIからモデルリストを取得できなかった場合でも、アプリケーションが操作不能になることを防ぎます。
5.  **ログの明確化**: ログメッセージを修正し、どのタイミングでどのようなデータに基づいてモデルリストが更新されているかをより追いやすくしました。特に、"init" (初期化処理) と "sync" (同期処理のスキップ判断など) を区別するようにしました。

この修正により、設定モーダルでユーザーが選択したモデル情報が、初回アクセス時およびその後のチャット送信時にも適切に保持・利用されるようになることが期待されます。

お手数ですが、再度動作をご確認いただき、問題が解消されたか、あるいは予期せぬ挙動が見られないかなど、ご確認いただけますでしょうか。

---

